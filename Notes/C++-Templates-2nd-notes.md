# C++ Templates 2nd Notes

## Chapter 1  Function Templates

+ 在自己定义了一个 `max` 函数模板后，调用时可以加上 `::` 表示在 global namespace 中找这个函数，以避免和 `std` namespace 中的 `max` 产生冲突，尤其是当参数为 `std` namespace 下的类型时：

  ```c++
  std::string s1 = "mathematics";
  std::string s2 = "math";
  std::cout << "max(s1, s2): " << ::max(s1, s2) << '\n';
  ```

+ 模板在编译时分两个阶段（two-phase translation）：定义时刻和实例化时刻。前者检查一些和模板参数无关的条件，而后者则检查一些和模板参数相关的条件。

+ 即使类型为模板参数（template parameter）的函数参数（call parameter）有默认值，模板参数的类型也不会自动推导出来，但是可以指定模板参数的默认类型：

  ```c++
  template<typename T = std::string>
  void f(T = "");
  
  f();
  ```

+ 当有多个模板参数而返回值类型是其中之一时，有以下几种方法来处理：

  + 将返回值类型也作为模板参数之一，然后在调用该函数时显式指定；
  + 使用 auto 作为返回值类型；
  + 使用 `common_type` type trait 作为返回值类型。

+ 当重载版本中同时出现函数模板和普通函数时，按照如下规则进行选择：

  + 如果显式指定了模板参数（或仅仅是指定了空参列表 `<>`），选择函数模板；
  + 如果普通函数（非模板）能完美匹配参数，选择普通函数；
  + 如果不需要转型，函数模板也能实例化一个完美匹配参数的模板函数，选择函数模板；
  + 需要转型的话，选择普通函数。

+ 在重载函数模板时，不同版本之间的区别应该尽可能小，比如只是参数个数不同，或者只是显式指定参数类型（而非声明为模板参数的类型）。

  此外，当别的函数需要用到重载函数时，应尽可能地将其声明在所有重载版本之后。

##### Last-modified date: 2020.5.31, 6 p.m.