# C++ Notes

## 智能指针

+ unique_ptr 禁用掉了拷贝构造和赋值重载，也即意味着它不能被赋值、赋值初始化、值传参、值返回（这一点编译器可能存在优化，因为返回后原函数内的 unique_ptr 就被销毁了，所以实现成移动构造的话值返回就是可行的）。

+ weak_ptr 表达临时所有权的概念，不会增加被指向的资源的引用计数。

  weak_ptr 可以通过一个 shared_ptr 或另一个 weak_ptr 进行构造。

  当需要通过 weak_ptr 访问资源时，需要先用 lock 方法将其转换成 shared_ptr 以获取资源的所有权。

  可以通过 expired 方法检查 weak_ptr 指向的资源的引用计数是否为 0（是否有其他 shared_ptr 指向它）

+ weak_ptr 可以用于解决循环引用的问题：

  ```
  +-----+  1  +-----+  2  +-----+  4  +-----+
  |  A  |---->|  a  |---->|  b  |<----|  B  |
  |     |     |     |<----|     |     |     |
  +-----+     +-----+  3  +-----+     +-----+
  ```

  当 A, B 退出作用于被销毁时，指针 1, 4 也被销毁，但是 a, b 并不会被释放，因为还有指针 2, 3 的存在。将指针 2, 3 改成 weak_ptr 可以解决这一问题。

## 右值引用和移动语义

+ C++ 11 引入，所谓右值引用，赋予了程序员修改右值的能力。在引入右值引用之前，是没有办法修改这个右值的，也即这个右值所在地址中的值不能被修改，只能一直是这个右值（可能存在一个误区：右值不能取地址，但不代表右值没有地址）：

  ```c++
  int &x = 5;       // Error
  const int &x = 5; // OK
  ```

  可见虽然可以将右值赋值给左值引用，但这个左值引用必须是常量引用，仍然无法修改其值。

  引入右值引用后，就可以将右值赋给右值引用，然后修改：

  ```c++
  int &&x = 5;
  x = 6;
  ```

+ 有了右值引用以后，就可以用来实现移动语义。移动是相对拷贝而言的，例如拷贝构造和拷贝赋值。如果被拷贝的对象是一个右值，实际上就没有必要真的拷贝了，将其内容直接转移给新对象，然后自己变成一个 null （即移动语义）可以节省一次拷贝的开销。

+ 利用移动语义的具体方法是实现移动构造和移动赋值：

  ```c++
  A(const A& a);             // 拷贝构造
  A& operator=(const A& a);  // 拷贝赋值
  A(A&& a);                  // 移动构造
  A& operator=(A&& a);       // 移动赋值
  ```

  对于实现了移动构造的类，编译器会根据用来构造的对象是左值还是右值自动调用拷贝构造或者移动构造。但是如果没有实现移动构造，那么不管用来构造的对象是左值还是右值，都只会调用拷贝构造。（前提是实现了拷贝构造）。总结一下：

  |                                | 用左值构造   | 用右值构造   |
  | ------------------------------ | ------------ | ------------ |
  | 未实现拷贝构造和移动构造       | 默认拷贝构造 | 默认移动构造 |
  | 实现了拷贝构造，未实现移动构造 | 拷贝构造     | 拷贝构造     |
  | 未实现拷贝构造，实现了移动构造 | 非法行为     | 移动构造     |
  | 实现了拷贝构造和移动构造       | 拷贝构造     | 移动构造     |

  所谓默认构造是说如果一个类没有显示声明拷贝构造或者移动构造，而又用到这些函数时，编译器会生成一个默认版本，默认版本的实现是：

  + 对于类中的对象成员，调用它们的拷贝构造或者移动构造（取决于该默认版本是默认拷贝还是默认移动）
  + 对于类中的基础类型数据成员（数组除外，例如指针，int），直接赋值（浅复制）
  + 对于类中的数组成员，将数组元素一个个复制过去（深复制）

+ 利用 `std::move()` 函数可以将一个左值转换成一个右值，这样可以使用移动语义，当构造之后不再需要这个左值时，该函数特别有用。

### 完美转发

+ 传参的时候，左值引用只能接受左值，右值引用只能接受右值，所以有时候需要进行重载：

  ```c++
  void f(int &x) {}
  void f(int &&x) {}
  ```

+ 完美转发是说，当形参是模板类型的右值引用时，可以根据实参是左值还是右值做不同推断：

  + 实参是左值时，推断为左值引用
  + 实参是右值时，推断为普通类型

  ```c++
  template<typename T>
  void f(T &&x) {
      h(forward<T>(x));
  }
  
  int a = 1;
  f(a);  // void f<int &>(int &x)
  f(1);  // void f<int>(int &&x)
  ```

  再配合上 `std::forward()` 函数，保留 x 的左 / 右值属性，做到完美转发。（forward 保留左 / 右值属性，而 move 强转成右值）

##### Last-modified date: 2020.3.4, 5 p.m.