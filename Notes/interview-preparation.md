# Interview Preparation Notes

## Network

+ IP 地址的分类：
  + A 类 IP 地址，由 1 字节的网络地址和 3 字节的主机地址组成，网络地址的最高位为 0（1 ~ 126）
  + B 类 IP 地址，由 2 字节的网络地址和 2 字节的主机地址组成，网络地址的最高位为 10（128 ~191）
  + C 类 IP 地址，由 3 字节的网络地址和 1 字节的主机地址组成，网络地址的最高位为 110（192 ~ 223）
  + D 类 IP 地址，用于多点广播，并不指向特定网络，第一个字节开头为 1110（224 ~ 239）
  + E 类 IP 地址，为将来使用保留，第一个字节开头为 1111（240 ~ 255）

+ IPv6 采用 128 位地址（IPv4 只有 32 位），16 位为一组，用 `:` 分隔，每组可以用 4 位 16 进制数表示。每一组中前导 0 可以省略，也可以用 `::` 表示一组或多组全 0，但只能出现一次。

+ IPv4 地址可以很容易的转换成 IPv6 地址，例如 `202.120.40.8` 可以被转换成 `::ffff:202.120.40.8`

+ TCP 和 UDP 的区别：

  |              | TCP                          | UDP                              |
  | ------------ | ---------------------------- | -------------------------------- |
  | 是否连接     | 面向连接                     | 无连接                           |
  | 是否可靠     | 可靠，使用流量控制和拥塞控制 | 不可靠，不使用流量控制和拥塞控制 |
  | 连接对象个数 | 一对一                       | 一对一，一对多，多对一，多对多   |
  | 传输方式     | 字节流                       | 报文                             |
  | 首部开销     | 小，8 字节                   | 大，20 ~ 60 字节                 |
  | 使用场景     | 要求可靠传输，例如传文件     | 要求实时性，例如直播、视频电话   |

  + 流量控制：接收方发送的确认报文中的窗口字段可以影响发送方的窗口大小，从而控制发送速率
  + 拥塞控制：慢开始（指数级上升），快恢复（速率减半，再线性上升）

## OS

+ 死锁的四个必要条件：
  + 互斥：一个资源每次只能被一个进程使用
  + 占有且等待：进程因请求资源而阻塞时，不会释放已获得的资源
  + 不可抢占：进程拥有的资源不能被抢占，只能由该进程显示释放
  + 循环等待：若干进程形成一条环路，环路上每个进程都在等待下一个进程拥有的资源
+ 死锁的处理方法：
  + 鸵鸟策略，当发生死锁时不会有多大影响或死锁概率很低，则可以选择忽略它
  + 乐观机制：多个进程同时放锁然后再抢；kill 掉某个进程
  + 悲观机制：给锁编号，进程只能按顺序申请；进程在一开始就请求完需要的所有锁

## Algorithms

### [打印素数](<https://github.com/labuladong/fucking-algorithm/blob/master/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%89%93%E5%8D%B0%E7%B4%A0%E6%95%B0.md>)

+ 埃氏筛法，时间复杂度为 O(nloglogn)
+ 优化：外层循环到 sqrt(n)，内层从 i^2 开始循环

### [编辑距离](<https://github.com/labuladong/fucking-algorithm/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.md>)

+ 一个字符串最少经过多少次增、删、替操作可以变到另一个字符串

+ > 解决两个字符串的动态规划问题，一般都是用两个指针 i,j 分别指向两个字符串的最后，然后一步步往前走，缩小问题的规模。

+ 有重叠子问题可以用**备忘录**或者**动规**来优化

+ 二维的 DP table 能不能优化成一维的可以看当前状态会从哪些状态转移过来

### [接雨水问题](<https://github.com/labuladong/fucking-algorithm/blob/master/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%8E%A5%E9%9B%A8%E6%B0%B4.md>)

+ 关注局部，考虑每个位置能接多少水

+ 穷举 O(n^2)，用备忘录以空间换时间

+ 考虑到备忘录空间复杂度为 O(n)，而这 n 个元素不会同时被用到（即每次遍历只会用到当前对应的元素），存在优化到 O(1) 的空间：双指针

  这种优化思路同样体现在上面编辑距离的问题中（二维 DP table 优化成一维），关键是看**同时**会用到多少数据，不会被同时用到的就没有必要占着空间。

### [数组去重](<https://github.com/labuladong/fucking-algorithm/blob/master/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%A6%82%E4%BD%95%E5%8E%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0.md>)

+ 对有序数组去重，尽量避免在数组内部删除元素

+ > 对于数组相关的算法问题，有一个通用的技巧：要尽量避免在中间删除元素，那就想办法把这个元素换到最后去

+ 使用快慢指针法：快指针在前面探路，找到不重复的元素就赋给慢指针，然后慢指针前进一位

### [回文子串](<https://github.com/labuladong/fucking-algorithm/blob/master/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.md>)

+ palindrome 回文

+ 双指针扩散法，时间复杂度 O(n^2)，需要注意回文子串长度为偶数的情况

+ [马拉车算法](<https://zhuanlan.zhihu.com/p/70532099>)，时间复杂度 O(n)

+ > 寻找回文串是从中间向两端扩展，判断回文串是从两端向中间收缩
  >
  > 对于单链表，无法直接倒序遍历，可以造一条新的反转链表，由于回文的特殊性，可以不完全反转链表，而是仅仅反转部分链表，将空间复杂度降到 O(1)。

### [寻找消失元素](<https://github.com/labuladong/fucking-algorithm/blob/master/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%B6%88%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0.md>)

+ 一个长度为 n 的数组，每个元素各不相同且取值范围为 0~n（n+1 种取值），求没有出现的那个值
+ 异或法
+ 索引减去对应的元素
+ 和寻找最小的未出现元素还是不一样

### [水塘抽样](<https://github.com/labuladong/fucking-algorithm/blob/master/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B7.md>)

+ 给你一个**未知长度**的链表，请你设计一个算法，**只能遍历一次**，随机地返回链表中的一个节点。
+ 当你遇到第 i 个元素时，应该有 1/i 的概率选择该元素，1 - 1/i 的概率保持原有的选择
+ 如果要随机选择 k 个数，只要在第 i 个元素处以 k/i 的概率选择该元素，以 1 - k/i 的概率保持原有选择即可

### [调度考生座位](<https://github.com/labuladong/fucking-algorithm/blob/master/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%BA%A7%E4%BD%8D%E8%B0%83%E5%BA%A6.md>)

+ > 但凡遇到在**动态过程中取最值**的要求，肯定要使用有序数据结构，我们常用的数据结构就是**二叉堆**和**平衡二叉搜索树**了

+ 二叉堆和平衡二叉树的操作复杂度都是 O(logn)，但是前者只能删除堆顶元素，而后者可以删除任一元素。但是堆本质就是数组，实现简单；相比之下平衡二叉树的实现更难（反正是用标准库其实也无所谓）。

### [并查集 Union-Find](<https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/UnionFind%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.md>)

+ 常用来解决**动态连通**问题，例如 DFS

##### Last-modified date: 2020.4.3, 4 p.m.